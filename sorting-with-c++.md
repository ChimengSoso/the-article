
# Sorting with C++ 

สวัสดีครับ นี่เป็นความรู้ทั้งหมดเกี่ยวกับการเรียงข้อมูลทุกรูปแบบบนโลกใบนี้ ต่อไปนี้หากเจอข้อมูลแบบไหนก็ตาม คุณจะเรียงมันได้ด้วยคำสั่งของภาษา C++ ครับ

## Basic

ว่าถึงปัญหากันก่อน ให้ชุดตัวเลขมาจำนวนหนึ่ง เช่นลำดับของ `[8, 5, 1, 4, 6, 2]` จงเรียงข้อมูลพวกนี้จากน้อยไปมาก ถ้าเราใช้เวลาสักพักก็จะเรียงได้แบบนี้ `[1, 2, 4, 5, 6, 8]`

ทีนี้โจทย์ของเราคือมาสั่งให้คอมมันเรียงอะ ทำไง

วิธีหนึ่งคือ ก็คิดลำดับขั้นตอนการเรียงมันนั่นแหละ ซึ่งสมัยก่อนก็มีคนคิดไว้มากมาย จนกลายเป็นชื่อต่าง ๆ นา ๆ อาทิ Bubble sort, Selection sort, Insertion sort, Merge sort, Quick sort ซึ่งรายละเอียดพวกนี้คุณไปหาเองได้ครับ ผมคงไม่สามารถสอนทุกอัลกอบนโลกในโน็ตนี้ได้นะ555

ถามว่าสำคัญไหมก็สำคัญนะ เพราะแนวคิดพวกนั้นเอาไปประยุกต์กับโจทย์หลาย ๆ ประเภทได้โดยเฉพาะไอ่ Merge sort อะตัวดีเลย แต่ถึงยังไงในโน็ตนี้จะขอ**เน้นเฉพาะ**ที่เรื่องการเรียงข้อมูลอย่างเดียวนะครับ นั่นคือได้ข้อมูลมา เอามาเรียงจากน้อยไปมากได้เสมอ แค่นั้นแหละ

### เริ่มต้นจากการศึกษา Bubble Sort แนวคิดนี้มาจากฟองสบู่ตามชื่อเลยครับ

อัลกอนี้มีแนวคิดว่า ทุกวินาทีที่ผ่านไป ฟองสบู่ที่เบากว่าจะลอยขึ้นได้สูงกว่าเพื่อน ๆ ทำให้ได้โค้ดเทียมดังนี้ครับ
``` c++
input a[1..n]              // รับข้อมูลใส่ใน array ตั้งแต่ช่องที่ 1 ถึง n
for i from 1 to n {        // วนจำนวน n รอบ
  for j from 1 to n-1 {    // ในแต่ละรอบจะทำการดันฟอง(ข้อมูล)ที่เบากว่าให้สูงขึ้น
    if (a[j] > a[j+1]) {   // ถ้าข้อมูลก้อนซ้ายมีความเบากว่าก้อนขวา
      swap(a[j], a[j+1])   // ให้ดันก่อนซ้ายขึ้น และผลักก้อนขวาลง ด้วยการสลับข้อมูล
    }
  }
}
```

เพียงแค่นี้ ข้อมูลก็เรียงแล้วหรอ?? ก็ใช่ไงครับ555 **สังเกตว่า** ในแต่ละรอบ ข้อมูลที่มีความเบาที่สุดในรอบนั้น จะได้ขึ้นไปอยู่ทางขวาสุดของลำดับ array เลย ดังนั้นกรณีแย่สุดคือข้อมูลมันเรียงย้อนกลับ ทำให้เราต้องวน n รอบเพื่อรับประกันว่าตัวที่น้อยที่สุดในแต่ละลำดับจะถูกย้ายไปอยู่ตำแหน่งของตัวเองครับ

ฟังดูอาจรู้สึกแปลก ๆ จากที่บอกว่า `a[j] > a[j+1]` มันแปลว่าข้อมูล a[j] เบากว่าข้อมูล `a[j+1]` ซึ่งตรงนี้เราก็มาดูนิยามความเบากันก่อน ว่าอะไรคือเบา โจทย์เดิมที่เราจะทำคือการเรียงข้อมูลจากน้อยไปมาก ดังนั้นนิยามความเบาในกรณีนี้คือ ใครมีข้อมูลมากกว่า แปลว่าตัวนั้นจะถูกผลักไปด้านขวา ดังนั้นจึงต้องเบา

ความสำคัญของอัลกอนี้คือ การเปรียบเทียบข้อมูลว่าใครเบากว่าใคร หรือบอกง่าย ๆ ว่าใครน้อยกว่าใครนั่นแหละ เช่น เราบอกได้นี่ว่า 1 < 5 หรือ 6 < 7 เป็นจริง แต่ถ้าเอาข้อมูลแปลก ๆ มาเปรียบเทียบความเบาละ จะดูยังไง เช่น เซตของข้อมูลคู่อันดับ (1, 5) กับคู่อันดับ (6, 2) อะไรแบบนี้

ทั้งหมดก็ขึ้นอยู่กับนิยามที่เราจะใส่ให้มันนั่นแหละ ว่าจะให้ (1, 5) < (6, 2) หรือ (6, 2) < (1, 5) เช่นโจทย์อาจบอกว่าเราให้เรียงตามแกน x ก่อน ละถ้าเท่ากันก็ให้ไปเรียงตามแกน y จากน้อยไปมากไรงี้ สิ่งเหล่านี้ก็ทำให้ย่อมได้มาซึ่งนิยามของความชัดเจนของความหนักเบาว่าใคร < หรือ > ใคร

ที่บอกมาทั้งหมดเป็นเพียงแนวคิดเพื่อให้ไปใช้กับการปฎิบัติที่จะบอกต่อไปนี้ นั่นคือ การใช้เครื่องมือที่เขามีมาให้อย่าง `std::sort()` นั่นเอง

`std::sort()` เป็นฟังก์ชันที่อยู่ใน `include file <algorithm>` ใช้ได้ในภาษาที่มีนามสกุลเป็นของภาษา C++ เท่านั้นนะครับ ก็คือพวกนามสกุล .cpp .cc เป็นต้น

ก่อนไปใช้งาน เรามาพูดถึงเรื่องช่วงของข้อมูลกันก่อน สมมติมีลำดับข้อมูลแบบนี้ `[6, 1, 5, 7, 8, 2]` มาให้ตั้งชื่อว่า a ละกัน โดยกำหนดการเข้าถึงเป็นแบบ 1-based index แปลว่า `a[1] = 6, a[2] = 1, a[3] = 5, ...`

ถ้าบอกว่าอยากได้ข้อมูลช่วง ปิด 1 ถึงเปิด 3 เราก็จะได้ว่า `a[1...3) = [6, 1]` หรืออยากได้ข้อมูลทั้งก้อนเลย ก็จะกลายเป็น ปิด 1 ถึงเปิด 7 จะได้เป็น `a[1...7) = [6, 1, 5, 7, 8, 2]` นั่นเอง

ทำไมต้องเป็นช่วงปิดและเปิดด้วย ทำไมไม่ใช้ช่วงปิดไปทั้งคู่เลยละ สะดวกนับกว่าอีก ก็จริงครับสำหรับเราอะนะ นั่นเพราะว่าเครื่องมือ `std::sort()` มันใช้ระบบช่วงปิดถึงช่วงเปิดนี่แหละครับ โดย Parameter ที่ใส่เข้าไปในฟังก์ชันนี้ พื้นฐานคือใส่เข้าไป 2 ตัวครับ มันจะแสดงถึงช่วงที่เราจะเรียงนั่นเอง

โดยในทางปฎิบัติเราจะใส่ข้อมูลเข้าไปเป็น address ของข้อมูลที่จะเรียงครับ ว่าละงงเยอะ ไปดูวิธีเขียนเลยดีกว่า

สมมติประกาศ array ขึ้นมาอันหนึ่ง (array ในภาษาซีและซีพลัสพลัสใช้ 0-base index นะครับ) ดังนั้นถ้าเรายืนยันจะใช้ 1-base index อยู่ก็แค่ทิ้งตัว index 0 ไปนั่นแหละ อะต่อ array นั้นชื่อ a (อีกแล้ว) มีข้อมูลเป็น `[6, 1, 5, 7, 8, 2]` เหมือนตัวอย่างข้างบน แต่จากการที่มันเป็น 0-index เราเลยจองเป็น `int a[] = {0, 6, 1, 5, 7, 8, 2};` แทน คือสังเกตว่าเราจองเพิ่มมาตัวหนึ่งที่อยู่หน้าสุด จะเป็นเลขอะไรก็ได้

ทีนี้ครับ เราจะเรียงข้อมูลด้วตัว `std::sort()` ขอเรียกว่า `sort()` เฉย ๆ นะครับ ไอ่ตัว `std::` อันนี้ประกาศ `using namespace std;` เอาก็ได้ มะต่อ เราจะใช้ `sort()` โดยเรียงข้อมูลของเรา ซึ่งจริง ๆ มันมี 6 ตัวนะ(ไม่รวมไอ่ที่จองเพิ่มมาตรงหน้าสุด) ขอประกาศตัวแปรมาอีกตัว เพื่อเก็บว่าข้อมูลที่เราจะ sort มีกี่ตัว ขอตั้งชื่อว่า n ดังนั้นตอนนี้เรามี `int n = 6;` นะครับ

จะใช้คำสั่ง sort ก็แค่ใส่ parameter ไปว่า `sort(a+1, a+n+1);` จบครับ มาดูทีละตัว เดิมที `a[]` ของเราเป็น array ดังนั้นการพิมพ์ว่า a หรือ a+0 จึงหมายถึง address ของช่องที่ 0 ครับ แต่เนื่องจากเราจะเรียงตั้งแต่ช่วงปิด 1 ไป เราก็ใส่ไปว่า a+1 เป็น parameter ตัวแรกครับ ทีนี้ช่วงเปิดที่เราจะหยุดคือตรงไหนล่ะ จากตัวอย่างเดิมเราจะเปิดถึง 7 เราก็ใส่ไปว่า a+7 เป็น parameter ตัวที่สองก็ได้ เพียงแต่ผมเขียนในรูปที่เอาไปใช้ต่อได้เฉย ๆ นั่นคือเรามีข้อมูลอยู่ n ตัว(ในที่นี้ n = 6) ดังนั้นเราจะทำช่วงเปิดก็แค่บวก n เพิ่มไปอีก 1 ทำให้คำสั่งใน parameter ตัวที่สองนี้เป็น a+n+1 นั่นเองครับ

โค้ดโดยรวมก็ได้ดังนี้ครับ
```c++
int a[] = {0, 6, 1, 5, 7, 8, 2};
int n = 6;
sort(a+1, a+n+1); // จะได้ a[] = {0, 1, 2, 5, 6, 7, 8}
// ปล.ถ้าใช้ 0-based index ก็แค่พิมพ์ไปว่า sort(a, a+n); แค่นี้เอง
// ตัวอย่างนี้ทำให้ดูยุ่งยากเพื่อจะได้รู้ทีเดียวไปเลยนะครับเรื่อง 0-based กับ 1-based index
```
**จบครับ พื้นฐานการใช้คำสั่ง sort อย่างถึงพริกถึงขิง**
## Advanced Topic

ต่อไปเป็นหัวข้อสนุกสนานที่ทำให้คุณเรียงข้อมูลอะไรก็ได้นอกจากตัวเลขเป็นครับ ข้อมูลที่ว่านั่นก็คือจำพวก struct นั่นเอง

สมัยอดีตอันนานแสนนานให้นิยาม struct ไว้ว่า เป็นกลุ่มก้อนของชนิดข้อมูล(Data type) จบครับ แต่ทั้งนี้ ในสมัยปัจจุบันนิยามนี้ก็ยังไม่ครอบคลุมเท่าไหร่ครับ เพราะใน struct ก็สามารถมี function ได้อีก...

ซึ่งเดี๋ยวเราค่อยพูดถึงละกันครับ เอาเป็นว่า ถ้าหากเรามีข้อมูลใน struct มากมาย ละเกิดอย่างเรียง struct แต่ละก้อน จะทำยังไง เช่น มี struct ดังต่อไปนี้
```c++
struct Data {
  string name;
  double gpa;
  unsigned int age;
  char gender;
};
Data A = {"chi", 3.80, 17, 'M'};
Data B = {"pirch", 3.59 , 18, 'M'};
```
ตามตัวอย่างนี้คือ ถ้าเราจะกล่าวว่า ข้อมูล A มีค่าน้อยกว่าหรือมากกว่าข้อมูล B ก้ต้องถามว่าจะใช้ข้อมูลอะไรเป็นเกณฑ์ล่ะ ถ้าใช้ gpa เป็นเกณฑ์ ก็จะได้ว่า A > B แต่ถ้าใช้ age เป็นเกณฑ์ก็จะได้ว่า A < B นั่นเอง ทั้งนี้ก็ขึ้นอยู่กับว่าเราจะใช้เกณฑ์อะไรนั่นแหละ แล้วเราจะสร้างเกณฑ์พวกนี้ในการเขียนโปรแกรมอย่างไร

วิธีหนึ่งที่จะขอนำเสนอคือ การใช้ compare function ครับ อ่ามันคืออะไร ก็ต้องบอกก่อนว่า ตัว function `sort()` เนี่ย มันสามารถรับ function ไปเป็น parameter ได้ครับ(อ่านดี ๆ นะครับ รับ function ไปเป็นพารามิเตอร์) โดย function ที่มันรับ จะเป็นตัวบอกว่าข้อมูลคู่ใด ๆ เนี่ย ตัวไหนมากหรือน้อยกว่ากัน ดูวิธีสร้างกันเลย

จากตัวอย่าง struct ด้านบนนะครับ ขอกำหนดให้ใช้เกณฑ์ว่า จงเรียงข้อมูลstructตาม gpa จากน้อยไปมาก เราก็จะเขียน function compare ดังนี้ครับ
```c++
bool cmp(Data leftData, Data rightData) { // cmp ย่อมาจากคำว่า compare
   if (leftData.gpa < rightData.gpa) {
      return true;
   } else {
      return false;
   }
}
// เวลาเรียกใช้ สมมติให้ array a มีชนิดเป็น sturct Data ต้องการเรียงช่วง index ตั้งแต่ปิด 1 ถึงเปิด n
// ก็สามารถเขียนคำสั่งดังนี้ สังเกตว่าเราใส่ชื่อ function cmp เข้าไป
// ใน sort() ตรงๆ ไม่ต้องใส่ parameter ของ cmp เพิ่มเข้าไปด้วย
sort(a+1, a+n+1, cmp); 
```
หลักการเขียนว่าจะ return true หรือ false อย่างไรนั้น ให้เข้าใจว่าแบบนี้ครับ **function `sort()` จะเรียงข้อมูลตามค่า true ของ `cmp` function** เช่นตัวอย่างโค้ดด้านบน เราเขียนreturn true เมื่อข้อมูล `leftData.gpa` น้อยกว่า `rightData.gpa` ก็มันก็จะเรียงข้อมูลแบบน้อยไปมากจากซ้ายไปขวาตามค่า gpa นั่นเอง

หากอยากให้เรียงจากมากไปน้อยก็เพียงแค่กลับเครื่องหมายใน `if` เป็น `leftData.gpa > rightData.gpa` นั่นเอง

ทั้งนี้สังเกตว่า เราจะ return ค่า true เมื่อเงื่อนไขเป็น true และจะ return ค่า false เมื่อเงื่อนไขเป็น false เราก็สามารถเขียน function compare ให้สั้นลงได้เหลือดังนี้
```c++
bool cmp(Data leftData, Data rightData) {
   return leftData.gpa < rightData.gpa;
}
```
และขอความกรุณา อย่าใส่เครื่องหมาย = ในเงื่อนไขดังกล่าวเพราะหากมันเท่ากัน เราไม่สามารถคาดเดาคำตอบหลังเรียงข้อมูลได้ เช่น `return leftData.gpa <= rightData.gpa` ละสมมติ gpa ของทั้งคู่เท่ากันคำสั่งนี้อาจทำให้ข้อมูล struct ของ `leftData` อยู่ซ้ายหรือขวาก็ได้ เช่นกันกับ `rightData` ด้วย ดังนั้นกรุณาเขียน < ก็น้อยกว่าไปเลยหรือจะเขียน > ก็มากกว่าไปเลย อย่าได้ใส่ = นะครับผม

แต่ทั้งนี้หากการเรียงข้อมูลมีความซับซ้อนขึ้นก็สามารถใช้กรณี = มาตัดสินได้เช่นการเรียงข้อมูลstruct ดังตัวอย่างด้านบน `struct Data` นั้น สมมติ หากโจทย์กำหนดให้เรียงข้อมูลจากซ้ายไปขวาโดยเรียงตามอายุ(age)จากน้อยไปมาก แต่หากอายุเท่ากันก็ให้เรียงตามเกรด(gpa)จากน้อยไปมากแบบนี้ เราก็เขียน `function compare` ได้ดังนี้
```c++
bool cmp(Data X, Data Y) { //ขอเปลี่ยนชื่อจาก leftData เป็น X และ rightData เป็น Y นะครับ
   if (X.age != Y.age) {
      return X.age < Y.age;
   } else {
      return X.gpa < Y.gpa;
   }
}
//เวลาเรียกใช้ก็เหมือนเดิมดังนี้
sort(a+1, a+n+1, cmp);
```
ต่อไปมาดูอีกตัวอย่างผ่อนคลายกันครับ จงเรียงเลขจำนวนเต็มจากมากไปน้อยโดยใช้ `compare function` ครับก็สามารถเขียนโค้ดได้ดังนี้ครับ
```c++
//ประกาศ function cmp ไว้นอก main เพื่อเอาไปใช้ใน function sort
bool cmp(int x, int y) {
   return x > y;
}
/*... in main function ...*/
int a[] = {1, 3, 5, 6, 9, 12, 4, 1}; // ประกาศ array ชื่อ a
int n = sizeof(a) / sizeof(a[0]);    // คำนวน byte ทั้งหมดของ a หารด้วย byte ของ a[0] จะได้
                                     // sizeof(a) = 4*8 เพราะมีสมาชิก 8 ตัวแต่ละตัวเป็น int
                                     // sizeof(a[0]) = 4 ดังนั้นจะได้ว่า n = (4*8)/4 = 8
sort(a, a+n, cmp); // เรียงข้อมูลตาม cmp function โดยเรียงแบบ 0-based index
// เท่านี้ a ก็จะมีข้อมูลเป็น {12, 9, 6, 5, 4, 3, 1, 1}
```
อีกตัวอย่างละกัน  สมมติให้ Array a มีข้อมูลดังนี้ [100, 50, 60, 70, 35] output คือลำดับของเลข 1 ถึง n ที่เรียงสับเปลี่ยนกัน ลำดับที่ออกมานี้เป็นการแสดงถึง**เลขลำดับเดิมของข้อมูล**ที่เรียงจากน้อยไปมาก เช่นในตัวอย่างนี้ เมื่อเรียงเสร็จเราจะได้ข้อมูลดังนี้ [35, 50, 60, 70, 100] ก็แปลงตรงนี้ไปเป็นเลขลำดับเดิมก่อนจะเรียง จะได้ว่า 35 เคยอยู่เลขลำดับที่ 5, 50 เคยอยู่เลขลำดับที่ 2, ุ60 เคยอยู่เลขลำดับที่ 3, 70 เคยอยู่เลขลำดับที่ 4, 100 เคยอยู่เลขลำดับที่ 1 ก็จะได้ output เป็น [5, 2, 3, 4, 1]  

สังเกตว่าครั้งนี้สิ่งที่เราต้องการเรียงจริง ๆ ไม่ใช่ลำดับ Array a แต่เป็นการเรียงลำดับ output ต่างหาก โดยเราจะใช้ Array a เป็นเกณฑ์ ก็จะเขียนโค้ดกึ่งเทียมได้ดังนี้
```c++
// --- global variable ---
create array idx[1..n] = [1 2 ... n]    // สร้าง array output
bool cmp(int idx_left, int idx_right) { // สร้างเกณฑ์วิธีการเรียงข้อมูล
     return a[idx_left] < a[idx_right]; // เรียง index ตามค่าข้อมูลที่อยู่ใน index นั้น
}
// --- in main function ---
input array a[1..n]   // รับข้อมูลเก็บไว้ใน array a
for i from 1 to n {   // วนลูปเพื่อสร้างเลขลำดับเดิมของ array a
    idx[i] = i;       // กำหนดค่าเลขลำดับเดิมของ array a
}
sort(idx+1, idx+n+1, cmp); // เอา array output ไปเรียงด้วยเกณฑ์วิธีของ cmp
// ผลลัพธ์หลังการเรียงเราก็จะได้ลำดับของเลขลำดับเดิมของ array จากน้อยไปมากแล้ว
// หากต้องการหน้าตาก็ array หลังเรียงโดยใช้ข้อมูลของ array output ก็ทำได้ดังนี้
for i from 1 to n {   // ลูปข้อมูลที่เรียงแล้วตั้งแต่ตัวที่ 1 ถึง n
    print a[ idx[i] ] // เนื่องจากสิ่งที่เรียงคือ array output 
    // ดังนั้นถ้าจะเข้าถึงมูลจริงที่เรียงแล้ว ก็ทำการวาร์ปไปยังช่องเดิมที่มันอยู่
}
```
## สรุปการ sort ข้อมูลที่มีความซับซ้อน โดยใช้ตัว compare function
1.  รู้โครงสร้างข้อมูลที่จะเรียง เช่น int char double struct etc.
2.  เขียน function ที่มี return type เป็น boolean เสมอและรับ parameter เป็นชนิดข้อมูลที่จะเรียง
3.  เขียนเกณฑ์วิธีในการเรียงข้อมูลดังตัวอย่างที่ได้แสดงไป

จบครับสำหรับการ `sort()` ข้อมูลใด ๆ ก็ได้ในโลกนี้ หากปรับให้มันอยู่ในรูป struct หรืออื่น ๆ ที่เรารู้โครงสร้างมันได้ เราก็สามารถสร้างเกณฑ์วิธีมา sort มันได้โดยใช้ **compare function** ครับ

## Expert Topic
ต่อไปในหัวข้อนี้จะเป็นหัวข้อที่เราค้างกันไว้ครับ นั่นคือใน struct ก็สามารถมี function ได้อีกนั่นเอง เช่น เราอาจอยากเขียน function แสดงข้อความสวย ๆ ได้ดังนี้
```c++
void print() {
  cout << "ChimengSoso is so smart >///<";
}
//เวลาเรียกใช้ก็เขียนดังนี้
print(); // จะได้ output เป็น ChimengSoso is so smart >///< ตามปกติ
```
ซึ่งเราสามารถประกาศฟังก์ชันนี้ใน struct ได้ดังนี้ครับ
```c++
struct DataType {
  void print() {
     cout << "ChimengSoso is so smart >///<"; 
  }
};
//เวลาจะเรียกใช้ก็ต้องประกาศตัวแปรชนิด struct นั้นก่อน
//ละค่อยเรียกคำสั่งใน struct นั้น ดังนี้ครับ
DataType var; // ประกาศ struct มาก่อน
var.print();  // output จะขึ้น ChimengSoso is so smart >///< เหมือนเดิม
```
ไวยากรณ์ลักษณะนี้เขียนได้เฉพาะในภาษาซีพลัสพลัสเท่าครับ ถ้าในซีเฉยๆจะเขียนไม่ได้ แต่ที่จะนำเสนอในโน็ตนี้ไม่ใช่เรื่องฟังก์ชันทั่วไปครับ เพราะมันมี function ตัวหนึ่งที่ประกาศนอก struct ไม่ได้ แถมเป็นฟังก์ชันพิเศษโดยเฉพาะสำหรับ struct เลย นามของเจ้าสิ่งนั้นคือ **operator function** ครับ

Operator แปลว่า ตัวดำเนินการครับ เดี๋ยวเราจะไปเข้าใจความหมายนี้อย่างลึกซึ้งกันต่อไปนะ

มาดูที่ไปที่มากันก่อนครับ ปกติเวลาพูดถึงชนิดข้อมูลเชิงเดี่ยว(Primary Data Type)อย่างพวก int char double เนี่ย เราก็รู้ว่าทั้งหมดนี้มันมี Operator ของมัน ขอใช้ int ยกตัวอย่างดังนี้ เราสามารถเข้าใจความของประพจน์ 1 < 10 หรือ 1 + 1 > 4 ได้ว่าจริงหรือเท็จ หรือเราก็รู้ว่า 5+2 มีค่าเป็นอะไร คอมพิวเตอร์เองก็เข้าใจแบบนั้นไม่ต่างจากเรา

แต่ทีนี้ เมื่อเราสร้างชนิดข้อมูลเชิงเดี่ยวให้มันมารวมกันจนกลายเป็นชนิดข้อมูลเชิงประกอบ(Compound Data Type)  อย่างพวก struct และ class **การที่เราจะดำเนินการบางอย่างเพื่อให้เกิดการกระทำระหว่างข้อมูลย่อมต้องมีการนิยามครับ**เช่น สมมติมี struct ของจุดในระนาบสองมิติดังนี้
```c++
struct Point {
  double x, y;
};
Point A = {3, 1}; // กำหนดให้ A.x = 3 และ A.y = 1
Point B = {2, 5}; // กำหนดให้ B.x = 2 และ B.y = 5
```
จากโค้ดนี้ ถ้าจะอยากจะดำเนินการกับข้อมูลแบบนี้ A*B-A หรือแบบนี้ A < B เราเขียนแบบนี้ตรง ๆ ได้ไหม ก็ในเมื่อ int ยังทำได้เลย คำตอบคือได้ครับ**ถ้าเรานิยามการดำเนินการนั้นเรียบร้อยแล้วอะนะ**

สิ่งที่จะเป็นตัวกำหนดการกระทำระหว่างชนิดข้อมูลประกอบพวกนี้ก็คือ operator function นั่นเองครับ และในวงการก็เรียกการกำหนดการดำเนินการแบบนี้ว่า Operator Overloading ครับ

อารมณ์แบบสร้างนิยามของเครื่องหมายหรือสัญลักษณ์ที่เคยมีอยู่แล้วให้ไปในทางที่เราต้องการนั่นเอง เลยเป็นที่มาของคำว่า Overloading (การทำมากกว่าปกติ)

โดยหน้าตาของมันตอนประกาศใน struct จะอยู่ในรูปแบบนี้ครับ
```c++
returnType operator[someSymbol](parameterList) {
   ... some statement ...
   return someResult;
}
```
key word สำคัญคือ มันมีคำว่า operator และมีเครื่องหมาย [someSymbol] ที่เราจะนิยามความหมายใหม่ให้มันแทนชื่อของ function นั่นเองครับ

โดย [someSymbol] เป็นได้หลายเครื่องหมายดังตารางต่อไปนี้ครับ
![ตารางเครื่องที่สามารถทำ Overloading ได้](https://lh3.googleusercontent.com/v90Lj6JIAJucQ6k5rvW4HWqUx0pLoBSsJQxDbp6B4ujavKNODqkBcRwbR_6-073kxU7r_s-NgcTn)

ดังนั้นใน struct Point ก็อาจมีการสร้าง operator function ดังนี้ครับ
```c++
struct Point {
  double x, y;
  double operator*(Point rhs) { // rhs ย่อมาจาก right hand side
    double dx = x - rhs.x;    // ไว้อธิบายความหมายของตรงนี้ทีย่อหน้าล่าง
    double dy = y - rhs.y;
	  return sqrt(dx*dx + dy*dy);
  }
};
Point A = {1, 2};
Point B = {4, 6};
double dst = A*B; // dst ก็จะเท่ากับ 5
```
จากตัวอย่างโค้ดนี้ เราได้กำหนดนิยามให้เครื่อง**หมายคูณ**(*)ระหว่างชนิดตัวแปร Point 2 ตัวคือระยะห่างระหว่างจุด 2 จุดนั่นเอง

ซึ่งการที่เราจะเอามาใช้กับฟังก์ชัน `sort()` เราเพียงตแค่ต้องนิยามเครื่องหมาย < (น้อยกว่า) นั่นเอง กลับมาที่ struct Point นะ สมมติโจทย์บอกอยากให้เรียงข้อมูลตามตัวแปร x ก่อนถ้าเท่ากันค่อยเรียงตามตัวแปร y ทั้งหมดเรียงจากน้อยไปมาก

เราก็สามารถใช้ compare function ก็ได้ แต่ถ้าจะใช้ operator function ให้มันคูล ๆ ก็ได้จะดังนี้ครับ
```c++
struct Point {
  double x, y;
  bool operator<(Point rhs) {
    if (x != rhs.x)
      return x < rhs.x;
    else
      return y < rhs.y;
  }
};
```
ซึ่งฟังก์ชันที่มีการนิยามลักษณะการเปรียบเทียบแบบนี้ เราก็พยายามจะสร้างฟังก์ชันที่ไม่ไปเปลี่ยนแปลงค่าของตัวแปรที่เปรียบเทียบเพราะเราแค่เปรียบเทียบ(compare)เท่านั้น ซึ่งคนในวงการก็เลยมักจะประกาศฟังก์ชันพวกนี้เป็น constant function **และ** constant parameter ครับ ก็จะได้โค้ดแบบนี้
```c++
struct Point {
  double x, y;
  bool operator<(const Point& rhs) const {
    if (x != rhs.x)
      return x < rhs.x;
    else
      return y < rhs.y;
  }
};
// เวลาเรียกใช้งานก็ไม่ต้องส่งฟังก์ชันเข้าไปใน sort() ละครับ
// สมมติมี array ชื่อ a มีชนิดเป็น struct Point และมีข้อมูล n ตัว
// ก็จะได้โค้ดดังนี้
sort(a, a+n); // สมมติใช้ zero-based index ละกัน
// จะเห็นเลยว่าเหมือนเราเอา array ปกติเข้าไปใช้ตรง ๆ
// แต่ด้านในคำสั่ง sort() เมื่อมีการใช้เครื่องหมาย < มันก็จะไปทำงานกับ operator function
// ที่เราได้นิยามหลักเกณฑ์การดำเนินการต่าง ๆ ไว้แล้วนั่นเอง
```
ส่วนความหมายของ rhs นั่นก็คือ เมื่อเราใช้ข้อมูล 2 ตัว(เน้นว่าแค่เพียง 2 ตัว) มาดำเนินการกัน ไอ่ตัวที่อยู่ขวามือของ Operator จะเป็นสิ่งเดียวกันค่าของตัวแปร rhs ของ function operator นั่นเอง เราเลยมองเป็นข้อมูลฝั่งซ้ายและข้อมูลฝั่งขวาเหมือน compare function ได้

สำหรับใครที่สนใจความสุดยอดของ Operator function ในรูปแบบอื่น ๆ นอกจากที่นำเสนอมา ศึกษาต่อได้ที่ [Link](https://www.tutorialspoint.com/cplusplus/cpp_overloading.htm) นี้ครับ

และนี่คือทั้งหมดของการเรียงข้อมูลในภาษาซีพลัสพลัสที่ผมศึกษามาครับ ทั้งนี้การเรียงข้อมูลนั้นก็สำคัญในหลาย ๆ ความหมาย แต่สิ่งที่สำคัญกว่านั้นคือ ข้อมูลที่เรียงแล้วสามารถเอามาใช้ประโยชน์อะไรได้ต่ากหาก เป็นสิ่งที่ควรศึกษาต่อไป

### References:
 - https://en.cppreference.com/w/cpp/algorithm/sort
 - http://www.cplusplus.com/reference/algorithm/sort/
 - https://en.wikipedia.org/wiki/Sort_(C%2B%2B)
 - https://www.tutorialspoint.com/cplusplus/cpp_overloading.htm
 - https://www.quora.com/What-is-an-operator-function-Is-the-operator-function-and-operator-overloading-the-same
 - https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.3.0/com.ibm.zos.v2r3.cbclx01/cplr318.htm
 - https://www.programiz.com/cpp-programming/operator-overloading
 - https://www.geeksforgeeks.org/sorting-algorithms/
